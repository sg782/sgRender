#version 460
/*
to draw triangle:

- depth buffer
- face buffer
- vertice buffer
- current position (to calculate depth)
- screen dimensions
- color buffer
https://fgiesen.wordpress.com/2011/07/06/a-trip-through-the-graphics-pipeline-2011-part-6/
https://www.youtube.com/watch?v=k5wtuKWmV48&t=3454s
*/

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants {
    float screen_width;
    float screen_height;
    float roll;
    float pitch;
    float yaw;
    float x;
    float y;
    float z;
} push;


layout(set = 0, binding = 0) buffer Faces {
    // first 3 values are vertex indices (relative to mesh), 
    // last value is the idx of the mesh
    uvec4 ids[];
} faces;

layout(set = 0, binding = 1) buffer RunningVerticeCount{
    uint data[];
} running_vertice_count;

layout(set = 0, binding = 2) buffer InView {
    uint data[];
} in_view;

layout(set = 0, binding = 3) buffer VertexData {
    vec4 data[];
} vertex_data;

layout(set = 0, binding = 4) buffer DepthBuffer {
    float data[];
} depth_buffer;

layout(set = 0, binding = 5) buffer ColorBuffer {
    uint data[];
} color_buffer;

layout(set = 0, binding = 6) buffer FaceNormalBuffer{
    vec4 data[];
} normal_buffer;

layout(set = 0, binding = 7, rgba8) uniform writeonly image2D img;

// add in color buffer


void sort_vertices(in vec4 v[3], out vec4 v_out[3]){
    // sorts vertices in order of y value

    // in order of y
    // v0.y <= v1.y <= v2.y
    vec4 v_0_out;
    vec4 v_1_out;
    vec4 v_2_out;

    // find top
    uint v0_idx = 3;
    float min_y = 99999.;
    for(int i=0;i<3;i++) {
        if(v[i][1] < min_y) {
            v0_idx = i;
            min_y = v[i][1];
        }
    }

    uint v2_idx = 3;
    float max_y = - 99999.;
    // find bottom
    for(int i=0;i<3;i++) {
        if (i == v0_idx) {continue;}

        if(v[i][1] > max_y){
            v2_idx = i;
            max_y = v[i][1];
        }
    }

    uint v1_idx = 3 - v0_idx - v2_idx;

    v_out[0] = v[v0_idx];
    v_out[1] = v[v1_idx];
    v_out[2] = v[v2_idx];
}

void sort_counter_clockwise(in vec4 v[3], out vec4 v_out[3]){

    vec2 center = vec2(
        (v[0][0] + v[1][0] + v[2][0]) / 3.,
        (v[0][1] + v[1][1] + v[2][1]) / 3.
    );

    float angle_0 = atan(v[0][1] - center[1], v[0][0] - center[0]);
    float angle_1 = atan(v[1][1] - center[1], v[1][0] - center[0]);
    float angle_2 = atan(v[2][1] - center[1], v[2][0] - center[0]);


    vec3 angles = vec3(angle_0,angle_1,angle_2);

    float max_theta = 3.141592;
    float min_theta = -3.141592;

    uint cv0_idx = 0;
    //uint v1_idx = 3;
    uint cv2_idx = 2;


    for(int i=0;i<3;i++){
        if(angles[i] > min_theta && angles[i] <= 0.){
            cv2_idx = i;
            min_theta = angles[i];
        }
        if(angles[i] < max_theta && angles[i] > 0.){
            cv0_idx = i;
            max_theta = angles[i];
        }
    }

    //uint cv1_idx = 3 - cv0_idx - cv2_idx;
    uint cv1_idx = (cv0_idx != 0 && cv2_idx != 0) ? 0 :
                   (cv0_idx != 1 && cv2_idx != 1) ? 1 : 2;


    // v_out[0] = v[cv0_idx];
    // v_out[1] = v[cv1_idx];
    // v_out[2] = v[cv2_idx];

    v_out[0] = v[2];
    v_out[1] = v[1];
    v_out[2] = v[0];



    return;

    // sorts vertices in order of y value

    // in order of y
    // v0.y <= v1.y <= v2.y
    vec4 v_0_out;
    vec4 v_1_out;
    vec4 v_2_out;

    // find top vertice (rightmost is tiebreaker)
    uint v0_idx = 3;
    float min_y = 99999.;
    for(int i=0;i<3;i++) {
        if(v[i][1] < min_y) {
            v0_idx = i;
            min_y = v[i][1];
        }

        else if(v[i][1] == min_y && v0_idx !=3){
            // if we have two points that share top coordinate, choose the right one
            if(v[i][0] > v[v0_idx][0]){
                // if the current vertice has a higher x value (more to the right)
                v0_idx = i;
            }
        }
    }

    


    // find next vertice counterclockwise
    uint v_left_idx = 3;
    float min_x = 99999.;
    // find left
    for(int i=0;i<3;i++) {
        if (i == v0_idx) {continue;}

        if(v[i][0] < min_x){
            v_left_idx = i;
            min_x = v[i][0];
        }
    }

    uint v_right_idx = 3 - v0_idx - v_left_idx;

    uint v_1_idx = 3;
    uint v_2_idx = 3;

    v_1_idx = v_left_idx;
    v_2_idx = v_right_idx;

    if(v[v_left_idx][1] > v[v_right_idx][1] && v[v_right_idx][0] < v[v0_idx][0]){
        // if left vertice is lower than remaining right vertice, then right vertice is the next counterclockwise
        // (draw it out if that didnt make sense)
        v_1_idx = v_right_idx;
        v_2_idx = v_left_idx;
    }

    v_out[0] = v[v0_idx];
    v_out[1] = v[v_1_idx];
    v_out[2] = v[v_2_idx];
}

void draw_flat_bottom_triangle(vec4 v0, vec4 v1, vec4 v2, uint face_id, float light_intensity){


    // top point is v0
    // v1 and v2 are equal y-vals

    float cur_x_1 = v0[0];
    float cur_x_2 = v0[0];

    vec4 right; // right point
    vec4 left;
    if(v1[0]>v2[0]){
        right = v1;
        left = v2;
    }else{
        right = v2;
        left = v1;
    }

    float inv_slope_1 = (left[0] - v0[0]) / (left[1] - v0[1]);
    float inv_slope_2 = (right[0] - v0[0]) / (right[1] - v0[1]);

    float median_z = left[3] + ((right[3] - left[3]) * ((v0[0] - left[0]) / (right[0] - left[0])));

    float dz_dy =  (median_z-v0[3])/(v2[1]-v0[1]);
    float dz_dx = (right[3]-left[3])/(right[0]-left[0]);



    float avg_depth = (v0[3] + v1[3] + v2[3]) / 3.;

    uint c = color_buffer.data[face_id];
    vec4 color = uvec4(
        mod(c,256),
        mod(c/256,256),
        mod(c/(256*256),256),
    0);



    for(float i=v0[1];i<=v1[1];i++){
        for(float j = cur_x_1; j< cur_x_2;j++){

            if(i<0 || i>=push.screen_height || j<0 || j>=push.screen_width) {
                return;
            }


            uint int_i = int(i+0.5);
            uint int_j = int(j+0.5);


            // float interpolated_invW = inv_median_z + ((i - v0[1]) * dz_dy) + ((j - v0[0]) * dz_dx);
            // float intermediate_depth = 1.0 / interpolated_invW;

            float intermediate_depth = v0[3] + ((i-v0[1]) * dz_dy) + ((j - v0[0]) * dz_dx);

            // if currently blocked
            if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > intermediate_depth){
                continue;
            }else{
                depth_buffer.data[int_i * int(push.screen_width) + int_j] = intermediate_depth;
            }

            vec4 to_write = color / 255;
            // if(i==v2[1] || i < v0[1] + 1 || j == min(cur_x_1,cur_x_2)|| j >= max(cur_x_1,cur_x_2) - 1){
            //     to_write = vec4(0.,0.,1.,1.);
            // }else{
            //     to_write = color / 255;
            // }

            to_write *= light_intensity;


            
            ivec2 coord = ivec2(int_j,int_i);
            imageStore(img, coord, to_write);     


        }

        cur_x_1 += inv_slope_1;
        cur_x_2 += inv_slope_2;

    }
}



float get_determinant(vec2 a, vec2 b, vec2 c){
    vec2 ab = b - a;
    vec2 ac = c - a;

    float det = (ab[1] * ac[0]) - (ab[0] * ac[1]);
    return det;
}


void draw_flat_bottom_triangle_half_space(vec4 v0, vec4 v1, vec4 v2, uint face_id, float light_intensity){
    float min_x = min(v0[0],min(v1[0],v2[0]));
    float max_x = max(v0[0],max(v1[0],v2[0]));

    float min_y = min(v0[1],min(v1[1],v2[1]));
    float max_y = max(v0[1],max(v1[1],v2[1]));

    vec4 right; // right point
    vec4 left;
    if(v1[0]>v2[0]){
        right = v1;
        left = v2;
    }else{
        right = v2;
        left = v1;
    }

    uint c = color_buffer.data[face_id];
    vec4 color = uvec4(
        mod(c,256),
        mod(c/256,256),
        mod(c/(256*256),256),
    0);

    float median_z = left[3] + ((right[3] - left[3]) * ((v0[0] - left[0]) / (right[0] - left[0])));

    float dz_dy =  (median_z-v0[3])/(v2[1]-v0[1]);
    float dz_dx = (right[3]-left[3])/(right[0]-left[0]);


    for(float i = min_y; i < max_y;i++){
        for(float j = min_x; j < max_x; j++){

            uint int_i = int(i);
            uint int_j = int(j);

            float intermediate_depth = v0[3] + ((i-v0[1]) * dz_dy) + ((j - v0[0]) * dz_dx);

            vec2 pixel_pos = vec2(j,i);


            float alpha = get_determinant(v0.xy, left.xy,pixel_pos);
            float beta = get_determinant(left.xy,right.xy,pixel_pos);
            float omega = get_determinant(right.xy,v0.xy,pixel_pos);


            if(alpha<0. || beta < 0. || omega <0.){
                continue;
            }

            if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > intermediate_depth){
                continue;
            }else{
                depth_buffer.data[int_i * int(push.screen_width) + int_j] = intermediate_depth;
            }

            vec4 to_write = color / 255;
            to_write *= light_intensity;
            ivec2 coord = ivec2(int_j,int_i);
            imageStore(img, coord, to_write);   


        }
    }
}

void draw_flat_top_triangle_half_space(vec4 v0, vec4 v1, vec4 v2, uint face_id, float light_intensity){
    float min_x = min(v0[0],min(v1[0],v2[0]));
    float max_x = max(v0[0],max(v1[0],v2[0]));

    float min_y = min(v0[1],min(v1[1],v2[1]));
    float max_y = max(v0[1],max(v1[1],v2[1]));

    float cur_x_1 = v2[0];
    float cur_x_2 = v2[0];

    vec4 right; // right point
    vec4 left;
    if(v0[0]>v1[0]){
        right = v0;
        left = v1;
    }else{
        right = v1;
        left = v0;
    }


    float inv_slope_1 = (left[0]- v2[0]) / (left[1]- v2[1]);
    float inv_slope_2 = (right[0] - v2[0]) / (right[1] - v2[1]);

    float median_z = left[3] + ((right[3] - left[3]) * ((v2[0] - left[0]) / (right[0] - left[0])));

    float dz_dy = (median_z - v2[3])/(v0[1]-v2[1]);
    float dz_dx = (right[3] - left[3])/(right[0]-left[0]);
    float avg_depth = (v0[3] + v1[3] + v2[3]) / 3.;

    uint c = color_buffer.data[face_id];
    vec4 color = uvec4(
        mod(c,256),
        mod(c/256,256),
        mod(c/(256*256),256),
        0);

    
    for(float i = max_y; i > min_y ;i--){
        for(float j = min_x; j < max_x; j++){
            uint int_i = int(i);
            uint int_j = int(j);

            float intermediate_depth = v2[3] + ((i-v2[1]) * dz_dy) + ((j - v2[0]) * dz_dx);

            vec2 pixel_pos = vec2(j,i);


            float alpha = get_determinant(v2.xy, right.xy,pixel_pos);
            float beta = get_determinant(right.xy,left.xy,pixel_pos);
            float omega = get_determinant(left.xy,v2.xy,pixel_pos);


            if(alpha<0. || beta < 0. || omega <0.){
                continue;
            }


            // if currently blocked
            if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > intermediate_depth){
                continue;
            }else{
                depth_buffer.data[int_i * int(push.screen_width) + int_j] = intermediate_depth;
            }

            vec4 to_write = color / 255;
            to_write *= light_intensity;
            ivec2 coord = ivec2(int_j,int_i);
            imageStore(img, coord, to_write);   

        }
    }
}

/*
    for(float i=v0[1];i<=v1[1];i++){
        for(float j = min(cur_x_1,cur_x_2); j<= max(cur_x_1,cur_x_2);j++){

            if(i<0 || i>=push.screen_height || j<0 || j>=push.screen_width) {
                return;
            }

            
            uint int_i = int(i + 0.5);
            uint int_j = int(j + 0.5);


            // float interpolated_invW = inv_median_z + ((i - v0[1]) * dz_dy) + ((j - v0[0]) * dz_dx);
            // float intermediate_depth = 1.0 / interpolated_invW;

            float intermediate_depth = v0[3] + ((i-v0[1]) * dz_dy) + ((j - v0[0]) * dz_dx);

            // if currently blocked
            if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > intermediate_depth){
                continue;
            }else{
                depth_buffer.data[int_i * int(push.screen_width) + int_j] = intermediate_depth;
            }

            vec4 to_write;
            if(i==v2[1] || i < v0[1] + 1 || j == min(cur_x_1,cur_x_2)|| j >= max(cur_x_1,cur_x_2) - 1){
                to_write = vec4(0.,0.,1.,1.);
            }else{
                to_write = color / 255;
            }

            to_write *= light_intensity;


            
            ivec2 coord = ivec2(int_j,int_i);
            imageStore(img, coord, to_write);     

        }

        cur_x_1 += inv_slope_1;
        cur_x_2 += inv_slope_2;

    }

*/


void draw_flat_top_triangle(vec4 v0, vec4 v1, vec4 v2, uint face_id, float light_intensity){

    // v0 and v1 are equal y-vals, centered at v2

    // float inv_slope_1 = (v2[0] - v0[0]) / (v2[1] - v0[1]);
    // float inv_slope_2 = (v2[0] - v1[0]) / (v2[1]- v1[1]);

    float cur_x_1 = v2[0];
    float cur_x_2 = v2[0];

    vec4 right; // right point
    vec4 left;
    if(v0[0]>v1[0]){
        right = v0;
        left = v1;
    }else{
        right = v1;
        left = v0;
    }


    float inv_slope_1 = (left[0]- v2[0]) / (left[1]- v2[1]);
    float inv_slope_2 = (right[0] - v2[0]) / (right[1] - v2[1]);

    // float left_inv_w = 1. / left[3];
    // float right_inv_w = 1. / right[3];
    // float v_2_inv_w = 1. / v2[3];

    // float inv_median_z = left_inv_w + ((right_inv_w-left_inv_w) * ((v2[0] - left[0]) / (right[0] - left[0])));



    float median_z = left[3] + ((right[3] - left[3]) * ((v2[0] - left[0]) / (right[0] - left[0])));

    float dz_dy = (median_z - v2[3])/(v0[1]-v2[1]);
    float dz_dx = (right[3] - left[3])/(right[0]-left[0]);

    // float dz_dy = (inv_median_z-v_2_inv_w)/(v0[1]-v2[1]);
    // float dz_dx = (right_inv_w-left_inv_w)/(right[0]-left[0]);


    float avg_depth = (v0[3] + v1[3] + v2[3]) / 3.;

    uint c = color_buffer.data[face_id];
    vec4 color = uvec4(
        mod(c,256),
        mod(c/256,256),
        mod(c/(256*256),256),
        0);
    

    for(float i = v2[1]; i>=v0[1]; i--){
        for(float j = min(cur_x_1,cur_x_2); j<=max(cur_x_1,cur_x_2);j++){

            if(i<0 || i>=push.screen_height || j<0 || j>=push.screen_width) {
                return;
            }


            uint int_i = int(i+0.5);
            uint int_j = int(j+0.5);


            // float interpolated_invW = inv_median_z + ((i - v2[1]) * dz_dy) + ((j - v2[0]) * dz_dx);
            // float intermediate_depth = 1.0 / interpolated_invW;

            float intermediate_depth = v2[3] + ((i-v2[1]) * dz_dy) + ((j - v2[0]) * dz_dx);


            // if currently blocked
            if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > intermediate_depth){
                continue;
            }else{
                depth_buffer.data[int_i * int(push.screen_width) + int_j] = intermediate_depth;
            }



            // if currently blocked
            // if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > avg_depth){
            //     continue;
            // }else{
            //     depth_buffer.data[int_i * int(push.screen_width) + int_j] = avg_depth;
            // }

            vec4 to_write = color/ 255;
            // if(i==v2[1] || i < v0[1] + 1 || j == min(cur_x_1,cur_x_2)|| j >= max(cur_x_1,cur_x_2) - 1){
            //     to_write = vec4(0.,0.,1.,1.);
            // }else{
            //     to_write = color / 255;
            // }

            to_write *= light_intensity;


            ivec2 coord = ivec2(int(j+0.5),int(i+0.5));
            imageStore(img, coord, to_write);   
              

        }

        cur_x_1 -= inv_slope_1;
        cur_x_2 -= inv_slope_2;
    }


}

void draw_full_half_space_triangle(vec4 v0, vec4 v1, vec4 v2, uint face_id, float light_intensity){
    float min_x = min(v0[0],min(v1[0],v2[0]));
    float max_x = max(v0[0],max(v1[0],v2[0]));

    float min_y = min(v0[1],min(v1[1],v2[1]));
    float max_y = max(v0[1],max(v1[1],v2[1]));


    // vec4 right; // right point
    // vec4 left;
    // if(v1[0]>v2[0]){
    //     right = v1;
    //     left = v2;
    // }else{
    //     right = v2;
    //     left = v1;
    // }

    // three points define a plane
    vec3 v_top = vec3(v0.xy,v0.w);
    vec3 v_left = vec3(v1.xy,v1.w);
    vec3 v_right = vec3(v2.xy,v2.w);
    vec3 a = v_top - v_left;
    vec3 b = v_top - v_right;

    vec3 screen_normal = normalize(cross(a,b));

    float dz_dy = (screen_normal.z != 0) ? (-screen_normal.y / screen_normal.z) : 0.0f;
    float dz_dx = (screen_normal.z != 0) ? (-screen_normal.x / screen_normal.z) : 0.0f;



    uint c = color_buffer.data[face_id];
    vec4 color = uvec4(
        mod(c,256),
        mod(c/256,256),
        mod(c/(256*256),256),
    0);



    for(float i = min_y; i <= max_y;i++){
        for(float j = min_x; j <= max_x; j++){

            uint int_i = int(i);
            uint int_j = int(j);

            float intermediate_depth = v0[3] + ((i-v0[1]) * dz_dy) + ((j - v0[0]) * dz_dx);

            vec2 pixel_pos = vec2(j,i);


            float alpha = get_determinant(v0.xy, v1.xy,pixel_pos);
            float beta = get_determinant(v1.xy,v2.xy,pixel_pos);
            float omega = get_determinant(v2.xy,v0.xy,pixel_pos);


            if(alpha<0. || beta < 0. || omega <0.){
                continue;
            }

            if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > intermediate_depth){
                continue;
            }else{
                depth_buffer.data[int_i * int(push.screen_width) + int_j] = intermediate_depth;
            }

            vec4 to_write = color / 255;
            to_write *= light_intensity;
            ivec2 coord = ivec2(int_j,int_i);
            imageStore(img, coord, to_write);   
            // ivec2 coord2 = ivec2(int_j,int_i+1);
            // imageStore(img, coord2, to_write);   
            // ivec2 coord3 = ivec2(int_j+1,int_i);
            // imageStore(img, coord3, to_write);   
            // ivec2 coord4 = ivec2(int_j+1,int_i+1);
            // imageStore(img, coord4, to_write);   

        }
    }
}


void draw_triangle(uint v_a_idx, uint v_b_idx, uint v_c_idx, uint face_id, vec3 normal){

    vec4 va = vertex_data.data[v_a_idx];
    vec4 vb = vertex_data.data[v_b_idx];
    vec4 vc = vertex_data.data[v_c_idx];

    vec4 inp[3];
    inp[0] = va;
    // inp[0] += 0.5; // attempt to clean up lines
    // floor(inp[0]);

    inp[1] = vb;     
    // inp[1] += 0.5;
    // floor(inp[1]);

    inp[2] = vc;
    // inp[2] += 0.5;
    // floor(inp[2]);

    vec3 float_normal = vec3(normal);
    

    vec4 outp[3];
    vec4 outp2[3];

    //sort_counter_clockwise(inp,outp);
    //sort_vertices(inp,outp);

    vec4 v0 = vc; //outp[0];
    vec4 v1 = vb; // outp[1];
    vec4 v2 = va; //outp[2];



    // manually define a point light at 0,0,0;
    float initial_intensity = 1.0;
    vec3 directional_light = vec3(1.,1.,1.);

    vec3 reflected_light = -1. * directional_light;

    float vec_dot = dot(float_normal, reflected_light);
    float combined_magnitudes = length(float_normal) * length(reflected_light);
    float intensity_scalar = vec_dot / combined_magnitudes;
    if(intensity_scalar<0){
        intensity_scalar = 0.;
    }

    float intermediate_intensity = initial_intensity * intensity_scalar; // this is final intensity if we have now ambient light

    float final_intensity = min(intermediate_intensity + 0.3,1.); // add in some ambient light



    draw_full_half_space_triangle(v0, v1, v2, face_id, final_intensity);

    return;
    if (v1[1] == v2[1]) {
        draw_flat_bottom_triangle(v0, v1, v2, face_id, final_intensity);
    }else if(v0[1] == v1[1]) {
        draw_flat_top_triangle(v0, v1, v2, face_id, final_intensity);
    }else{

        // calculating intersection point for both triangles

         

        float alpha = (v1[1] - v0[1]) / (v2[1] - v0[1]);
        float v3_x = v0[0] + (alpha * (v2[0] - v0[0]));

        float v3_w = v0[3] + alpha * (v2[3] - v0[3]);

        // float a = (1. / v0[3]);
        // float b = (1. / v1[3]);
        // float c = (1. / v2[3]);

        // float avg = (a + b + c) / 3.;

        vec4 v3 = vec4(v3_x,v1[1],0,v3_w);

        draw_flat_bottom_triangle(v0,v1,v3, face_id, final_intensity); // works inie

        draw_flat_top_triangle(v3, v1, v2, face_id,final_intensity);
    }
}


void main() {

   // float t = push.current_heading[0];
    //float q = push.current_position[0];


    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;

    // yes i understand the following lines are redundant and inefficient, it is for testing
    uint id = idx * 16 + idy;
    uvec4 face = faces.ids[id]; // get face

    if(in_view.data[face[3]]==0){ // return early if not in view
        return;
    }

    // get the indices of each vertex, factoring in offset from how we store the data
    uint v_0_idx = face[0] + running_vertice_count.data[face[3]];
    uint v_1_idx = face[1] + running_vertice_count.data[face[3]];
    uint v_2_idx = face[2] + running_vertice_count.data[face[3]];

    draw_triangle(v_0_idx,v_1_idx,v_2_idx,face[3],normal_buffer.data[id].xyz);

}


void debug_statements_dont_run(){

    // flat top triangle outliner
    /*
    vec4 to_write;
    if(i==v2[1] || i < v0[1] + 1 || j == min(cur_x_1,cur_x_2)|| j >= max(cur_x_1,cur_x_2) - 1){
        to_write = vec4(0.,0.,1.,1.);
    }else{
        to_write = color / 255;
    }
    */

    // flat bottom triangle outliner
    /*
    vec4 to_write;
    if(i==v0[1] || i > v1[1] - 1 || j == min(cur_x_1,cur_x_2)|| j >= max(cur_x_1,cur_x_2) - 1){
        to_write = vec4(0.,0.,1.,1.);
    }else{
        to_write = color / 255;
    }
    */


}

