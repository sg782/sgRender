#version 460
/*
to draw triangle:

- depth buffer
- face buffer
- vertice buffer
- current position (to calculate depth)
- screen dimensions
- color buffer
*/

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants {
    float screen_width;
    float screen_height;
    float roll;
    float pitch;
    float yaw;
    float x;
    float y;
    float z;
} push;


layout(set = 0, binding = 0) buffer Faces {
    // first 3 values are vertex indices (relative to mesh), 
    // last value is the idx of the mesh
    uvec4 ids[];
} faces;

layout(set = 0, binding = 1) buffer RunningVerticeCount{
    uint data[];
} running_vertice_count;

layout(set = 0, binding = 2) buffer InView {
    uint data[];
} in_view;

layout(set = 0, binding = 3) buffer VertexData {
    vec4 data[];
} vertex_data;

layout(set = 0, binding = 4) buffer DepthBuffer {
    float data[];
} depth_buffer;

layout(set = 0, binding = 5) buffer ColorBuffer {
    uint data[];
} color_buffer;



layout(set = 0, binding = 6, rgba8) uniform writeonly image2D img;

// add in color buffer


void sort_vertices(in vec4 v[3], out vec4 v_out[3]){

    // in order of y
    // v1.y <= v2.y <= v3.y
    vec4 v_0_out;
    vec4 v_1_out;
    vec4 v_2_out;

    // find top
    uint v0_idx = 3;
    float min_y = 99999.;
    for(int i=0;i<3;i++) {
        if(v[i][1] < min_y) {
            v0_idx = i;
            min_y = v[i][1];
        }
    }

    uint v2_idx = 3;
    float max_y = - 99999.;
    // find bottom
    for(int i=0;i<3;i++) {
        if (i == v0_idx) {continue;}

        if(v[i][1] > max_y){
            v2_idx = i;
            max_y = v[i][1];
        }
    }

    uint v1_idx = 3 - v0_idx - v2_idx;

    v_out[0] = v[v0_idx];
    v_out[1] = v[v1_idx];
    v_out[2] = v[v2_idx];
}

void draw_flat_bottom_triangle(vec4 v0, vec4 v1, vec4 v2, uint face_id){
    float inv_slope_1 = (v1[0] - v0[0]) / (v1[1] - v0[1]);
    float inv_slope_2 = (v2[0] - v0[0]) / (v2[1]- v0[1]);

    float cur_x_1 = v0[0];
    float cur_x_2 = v0[0];


    for(float i=v0[1];i<v1[1];i++){
        for(float j = min(cur_x_1,cur_x_2); j< max(cur_x_1,cur_x_2);j++){

            if(i<0 || i>=push.screen_height || j<0 || j>=push.screen_width) {
                return;
            }

            
            uint int_i = int(i+0.5);
            uint int_j = int(j+0.5);

            // if currently blocked
            if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > v0[3]){
                continue;
            }else{
                depth_buffer.data[int_i * int(push.screen_width) + int_j] = v0[3];
            }

            uint c = color_buffer.data[face_id];
            vec4 color = uvec4(
                mod(c,256),
                mod(c/256,256),
                mod(c/(256*256),256),
                0);
            vec4 to_write = color / 255;

            ivec2 coord = ivec2(int(j+0.5),int(i+0.5));
            imageStore(img, coord, to_write);     

        }

        cur_x_1 += inv_slope_1;
        cur_x_2 += inv_slope_2;

    }
}


void draw_flat_top_triangle(vec4 v0, vec4 v1, vec4 v2, uint face_id){
    float inv_slope_1 = (v2[0] - v0[0]) / (v2[1] - v0[1]);
    float inv_slope_2 = (v2[0] - v1[0]) / (v2[1]- v1[1]);

    float cur_x_1 = v2[0];
    float cur_x_2 = v2[0];



    

    for(float i = v2[1]; i>v0[1]; i--){
        for(float j = min(cur_x_1,cur_x_2); j<max(cur_x_1,cur_x_2);j++){

            if(i<0 || i>=push.screen_height || j<0 || j>=push.screen_width) {
                return;
            }


            uint int_i = int(i+0.5);
            uint int_j = int(j+0.5);

            // if currently blocked
            if(depth_buffer.data[int_i * int(push.screen_width) + int_j] > v0[3]){
                continue;
            }else{
                depth_buffer.data[int_i * int(push.screen_width) + int_j] = v0[3];
            }


            uint c = color_buffer.data[face_id];
            vec4 color = uvec4(
                mod(c,256),
                mod(c/256,256),
                mod(c/(256*256),256),
                0);
            vec4 to_write = color / 255;



            ivec2 coord = ivec2(int(j+0.5),int(i+0.5));
            imageStore(img, coord, to_write);     

        }

        cur_x_1 -= inv_slope_1;
        cur_x_2 -= inv_slope_2;
    }


}


void draw_triangle(uint v_a_idx, uint v_b_idx, uint v_c_idx, uint face_id){
    vec4 va = vertex_data.data[v_a_idx];
    vec4 vb = vertex_data.data[v_b_idx];
    vec4 vc = vertex_data.data[v_c_idx];

    vec4 inp[3];
    inp[0] = va;
    inp[1] = vb;
    inp[2] = vc;

    vec4 outp[3];

    sort_vertices(inp,outp);

    vec4 v0 = outp[0];
    vec4 v1 = outp[1];
    vec4 v2 = outp[2];



    if (v1[1] == v2[1]) {
        draw_flat_bottom_triangle(v0, v1, v2, face_id);
    }else if(v0[1] == v1[1]) {
        draw_flat_top_triangle(v0, v1, v2, face_id);
    }else{

        // calculating intersection point for both triangles
        float v3_x = v0[0] + ((v1[1] - v0[1]) / (v2[1] - v0[1])) * (v2[0] - v0[0]);
        vec4 v3 = vec4(v3_x,v1[1],0,0);

        draw_flat_bottom_triangle(v0,v1,v2, face_id); 
        draw_flat_top_triangle(v1, v3, v2, face_id);
    }
}


void main() {
    uint i = running_vertice_count.data[0] + int(push.screen_width+push.screen_height) ;
    uint j = in_view.data[0];
    vec4 k = vertex_data.data[0];
    float d = depth_buffer.data[0];
    uint g = color_buffer.data[0];

   // float t = push.current_heading[0];
    //float q = push.current_position[0];


    uint idx = gl_GlobalInvocationID.x;
    uint idy = gl_GlobalInvocationID.y;

    // yes i understand the following lines are redundant and inefficient, it is for testing
    uvec4 face = faces.ids[idx * 16 + idy]; // get face

    if(in_view.data[face[3]]==0){ // return early if not in view
        return;
    }

    // get the indices of each vertex, factoring in offset from how we store the data
    uint v_0_idx = face[0] + running_vertice_count.data[face[3]];
    uint v_1_idx = face[1] + running_vertice_count.data[face[3]];
    uint v_2_idx = face[2] + running_vertice_count.data[face[3]];

    draw_triangle(v_0_idx,v_1_idx,v_2_idx,face[3]);

}

